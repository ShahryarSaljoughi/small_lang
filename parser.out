Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    STRING
    comment

Grammar

Rule 0     S' -> program
Rule 1     program -> A B C BEGIN D END
Rule 2     A -> empty
Rule 3     A -> CONST A_1
Rule 4     A_1 -> const_decl
Rule 5     A_1 -> const_decl A_1
Rule 6     B -> empty
Rule 7     B -> VAR B_1
Rule 8     B_1 -> var_decl
Rule 9     B_1 -> var_decl B_1
Rule 10    C -> empty
Rule 11    C -> proc_decl C
Rule 12    D -> statement
Rule 13    D -> statement D
Rule 14    const_decl -> identifier E = integer_constant
Rule 15    E -> empty
Rule 16    E -> , identifier E
Rule 17    var_decl -> identifier E : type
Rule 18    proc_decl -> PROCEDURE identifier ( F ) ; block
Rule 19    F -> empty
Rule 20    F -> format F_1
Rule 21    F_1 -> empty
Rule 22    F_1 -> ; format F_1
Rule 23    format -> identifier E : type
Rule 24    format -> identifier E : mode type
Rule 25    mode -> IN
Rule 26    mode -> OUT
Rule 27    mode -> IN_OUT
Rule 28    type -> INTEGER
Rule 29    block -> BEGIN A B D END
Rule 30    block -> BEGIN A B END
Rule 31    print -> PRINT ( string_constant G )
Rule 32    G -> empty
Rule 33    G -> , expression G
Rule 34    read -> READ ( string_constant H )
Rule 35    H -> empty
Rule 36    H -> , var H
Rule 37    cond -> IF bool THEN statement
Rule 38    cond -> IF bool THEN statement ELSE statement
Rule 39    call -> CALL identifier ( )
Rule 40    call -> CALL identifier ( expression G )
Rule 41    var -> identifier
Rule 42    var -> identifier [ expression ]
Rule 43    statement_assign -> var assign_op expression
Rule 44    statement -> block
Rule 45    statement -> print
Rule 46    statement -> read
Rule 47    statement -> statement_assign
Rule 48    statement -> cond
Rule 49    statement -> statement_for
Rule 50    statement -> return
Rule 51    statement -> call
Rule 52    return -> RETURN
Rule 53    bool -> NOT bool
Rule 54    bool -> bool AND bool
Rule 55    bool -> bool OR bool
Rule 56    bool -> expression relop expression
Rule 57    bool -> ( bool )
Rule 58    empty -> <empty>
Rule 59    statement_for -> FOR identifier assign_op TO expression DO statement
Rule 60    relop -> =
Rule 61    relop -> less_equal_sign
Rule 62    relop -> >
Rule 63    relop -> greater_equal_sign
Rule 64    relop -> <
Rule 65    relop -> not_equal_sign
Rule 66    expression -> integer_constant
Rule 67    expression -> expression + expression
Rule 68    expression -> expression - expression
Rule 69    expression -> expression * expression
Rule 70    expression -> expression / expression
Rule 71    expression -> - expression
Rule 72    expression -> ( expression )
Rule 73    expression -> var

Terminals, with rules where they appear

(                    : 18 31 34 39 40 57 72
)                    : 18 31 34 39 40 57 72
*                    : 69
+                    : 67
,                    : 16 33 36
-                    : 68 71
/                    : 70
:                    : 17 23 24
;                    : 18 22
<                    : 64
=                    : 14 60
>                    : 62
AND                  : 54
BEGIN                : 1 29 30
CALL                 : 39 40
CONST                : 3
DO                   : 59
ELSE                 : 38
END                  : 1 29 30
FOR                  : 59
IF                   : 37 38
IN                   : 25
INTEGER              : 28
IN_OUT               : 27
NOT                  : 53
OR                   : 55
OUT                  : 26
PRINT                : 31
PROCEDURE            : 18
READ                 : 34
RETURN               : 52
STRING               : 
THEN                 : 37 38
TO                   : 59
VAR                  : 7
[                    : 42
]                    : 42
assign_op            : 43 59
comment              : 
error                : 
greater_equal_sign   : 63
identifier           : 14 16 17 18 23 24 39 40 41 42 59
integer_constant     : 14 66
less_equal_sign      : 61
not_equal_sign       : 65
string_constant      : 31 34

Nonterminals, with rules where they appear

A                    : 1 29 30
A_1                  : 3 5
B                    : 1 29 30
B_1                  : 7 9
C                    : 1 11
D                    : 1 13 29
E                    : 14 16 17 23 24
F                    : 18
F_1                  : 20 22
G                    : 31 33 40
H                    : 34 36
block                : 18 44
bool                 : 37 38 53 54 54 55 55 57
call                 : 51
cond                 : 48
const_decl           : 4 5
empty                : 2 6 10 15 19 21 32 35
expression           : 33 40 42 43 56 56 59 67 67 68 68 69 69 70 70 71 72
format               : 20 22
mode                 : 24
print                : 45
proc_decl            : 11
program              : 0
read                 : 46
relop                : 56
return               : 50
statement            : 12 13 37 38 38 59
statement_assign     : 47
statement_for        : 49
type                 : 17 23 24
var                  : 36 43 73
var_decl             : 8 9

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . A B C BEGIN D END
    (2) A -> . empty
    (3) A -> . CONST A_1
    (58) empty -> .

    CONST           shift and go to state 2
    VAR             reduce using rule 58 (empty -> .)
    PROCEDURE       reduce using rule 58 (empty -> .)
    BEGIN           reduce using rule 58 (empty -> .)

    program                        shift and go to state 1
    A                              shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (3) A -> CONST . A_1
    (4) A_1 -> . const_decl
    (5) A_1 -> . const_decl A_1
    (14) const_decl -> . identifier E = integer_constant

    identifier      shift and go to state 6

    const_decl                     shift and go to state 5
    A_1                            shift and go to state 7

state 3

    (1) program -> A . B C BEGIN D END
    (6) B -> . empty
    (7) B -> . VAR B_1
    (58) empty -> .

    VAR             shift and go to state 8
    PROCEDURE       reduce using rule 58 (empty -> .)
    BEGIN           reduce using rule 58 (empty -> .)

    B                              shift and go to state 9
    empty                          shift and go to state 10

state 4

    (2) A -> empty .

    VAR             reduce using rule 2 (A -> empty .)
    PROCEDURE       reduce using rule 2 (A -> empty .)
    BEGIN           reduce using rule 2 (A -> empty .)
    END             reduce using rule 2 (A -> empty .)
    PRINT           reduce using rule 2 (A -> empty .)
    READ            reduce using rule 2 (A -> empty .)
    IF              reduce using rule 2 (A -> empty .)
    FOR             reduce using rule 2 (A -> empty .)
    RETURN          reduce using rule 2 (A -> empty .)
    CALL            reduce using rule 2 (A -> empty .)
    identifier      reduce using rule 2 (A -> empty .)


state 5

    (4) A_1 -> const_decl .
    (5) A_1 -> const_decl . A_1
    (4) A_1 -> . const_decl
    (5) A_1 -> . const_decl A_1
    (14) const_decl -> . identifier E = integer_constant

  ! shift/reduce conflict for identifier resolved as shift
    VAR             reduce using rule 4 (A_1 -> const_decl .)
    PROCEDURE       reduce using rule 4 (A_1 -> const_decl .)
    BEGIN           reduce using rule 4 (A_1 -> const_decl .)
    END             reduce using rule 4 (A_1 -> const_decl .)
    PRINT           reduce using rule 4 (A_1 -> const_decl .)
    READ            reduce using rule 4 (A_1 -> const_decl .)
    IF              reduce using rule 4 (A_1 -> const_decl .)
    FOR             reduce using rule 4 (A_1 -> const_decl .)
    RETURN          reduce using rule 4 (A_1 -> const_decl .)
    CALL            reduce using rule 4 (A_1 -> const_decl .)
    identifier      shift and go to state 6

  ! identifier      [ reduce using rule 4 (A_1 -> const_decl .) ]

    const_decl                     shift and go to state 5
    A_1                            shift and go to state 11

state 6

    (14) const_decl -> identifier . E = integer_constant
    (15) E -> . empty
    (16) E -> . , identifier E
    (58) empty -> .

    ,               shift and go to state 12
    =               reduce using rule 58 (empty -> .)

    empty                          shift and go to state 13
    E                              shift and go to state 14

state 7

    (3) A -> CONST A_1 .

    VAR             reduce using rule 3 (A -> CONST A_1 .)
    PROCEDURE       reduce using rule 3 (A -> CONST A_1 .)
    BEGIN           reduce using rule 3 (A -> CONST A_1 .)
    END             reduce using rule 3 (A -> CONST A_1 .)
    PRINT           reduce using rule 3 (A -> CONST A_1 .)
    READ            reduce using rule 3 (A -> CONST A_1 .)
    IF              reduce using rule 3 (A -> CONST A_1 .)
    FOR             reduce using rule 3 (A -> CONST A_1 .)
    RETURN          reduce using rule 3 (A -> CONST A_1 .)
    CALL            reduce using rule 3 (A -> CONST A_1 .)
    identifier      reduce using rule 3 (A -> CONST A_1 .)


state 8

    (7) B -> VAR . B_1
    (8) B_1 -> . var_decl
    (9) B_1 -> . var_decl B_1
    (17) var_decl -> . identifier E : type

    identifier      shift and go to state 16

    B_1                            shift and go to state 17
    var_decl                       shift and go to state 15

state 9

    (1) program -> A B . C BEGIN D END
    (10) C -> . empty
    (11) C -> . proc_decl C
    (58) empty -> .
    (18) proc_decl -> . PROCEDURE identifier ( F ) ; block

    BEGIN           reduce using rule 58 (empty -> .)
    PROCEDURE       shift and go to state 21

    proc_decl                      shift and go to state 18
    C                              shift and go to state 19
    empty                          shift and go to state 20

state 10

    (6) B -> empty .

    PROCEDURE       reduce using rule 6 (B -> empty .)
    BEGIN           reduce using rule 6 (B -> empty .)
    END             reduce using rule 6 (B -> empty .)
    PRINT           reduce using rule 6 (B -> empty .)
    READ            reduce using rule 6 (B -> empty .)
    IF              reduce using rule 6 (B -> empty .)
    FOR             reduce using rule 6 (B -> empty .)
    RETURN          reduce using rule 6 (B -> empty .)
    CALL            reduce using rule 6 (B -> empty .)
    identifier      reduce using rule 6 (B -> empty .)


state 11

    (5) A_1 -> const_decl A_1 .

    VAR             reduce using rule 5 (A_1 -> const_decl A_1 .)
    PROCEDURE       reduce using rule 5 (A_1 -> const_decl A_1 .)
    BEGIN           reduce using rule 5 (A_1 -> const_decl A_1 .)
    END             reduce using rule 5 (A_1 -> const_decl A_1 .)
    PRINT           reduce using rule 5 (A_1 -> const_decl A_1 .)
    READ            reduce using rule 5 (A_1 -> const_decl A_1 .)
    IF              reduce using rule 5 (A_1 -> const_decl A_1 .)
    FOR             reduce using rule 5 (A_1 -> const_decl A_1 .)
    RETURN          reduce using rule 5 (A_1 -> const_decl A_1 .)
    CALL            reduce using rule 5 (A_1 -> const_decl A_1 .)
    identifier      reduce using rule 5 (A_1 -> const_decl A_1 .)


state 12

    (16) E -> , . identifier E

    identifier      shift and go to state 22


state 13

    (15) E -> empty .

    =               reduce using rule 15 (E -> empty .)
    :               reduce using rule 15 (E -> empty .)


state 14

    (14) const_decl -> identifier E . = integer_constant

    =               shift and go to state 23


state 15

    (8) B_1 -> var_decl .
    (9) B_1 -> var_decl . B_1
    (8) B_1 -> . var_decl
    (9) B_1 -> . var_decl B_1
    (17) var_decl -> . identifier E : type

  ! shift/reduce conflict for identifier resolved as shift
    PROCEDURE       reduce using rule 8 (B_1 -> var_decl .)
    BEGIN           reduce using rule 8 (B_1 -> var_decl .)
    END             reduce using rule 8 (B_1 -> var_decl .)
    PRINT           reduce using rule 8 (B_1 -> var_decl .)
    READ            reduce using rule 8 (B_1 -> var_decl .)
    IF              reduce using rule 8 (B_1 -> var_decl .)
    FOR             reduce using rule 8 (B_1 -> var_decl .)
    RETURN          reduce using rule 8 (B_1 -> var_decl .)
    CALL            reduce using rule 8 (B_1 -> var_decl .)
    identifier      shift and go to state 16

  ! identifier      [ reduce using rule 8 (B_1 -> var_decl .) ]

    var_decl                       shift and go to state 15
    B_1                            shift and go to state 24

state 16

    (17) var_decl -> identifier . E : type
    (15) E -> . empty
    (16) E -> . , identifier E
    (58) empty -> .

    ,               shift and go to state 12
    :               reduce using rule 58 (empty -> .)

    empty                          shift and go to state 13
    E                              shift and go to state 25

state 17

    (7) B -> VAR B_1 .

    PROCEDURE       reduce using rule 7 (B -> VAR B_1 .)
    BEGIN           reduce using rule 7 (B -> VAR B_1 .)
    END             reduce using rule 7 (B -> VAR B_1 .)
    PRINT           reduce using rule 7 (B -> VAR B_1 .)
    READ            reduce using rule 7 (B -> VAR B_1 .)
    IF              reduce using rule 7 (B -> VAR B_1 .)
    FOR             reduce using rule 7 (B -> VAR B_1 .)
    RETURN          reduce using rule 7 (B -> VAR B_1 .)
    CALL            reduce using rule 7 (B -> VAR B_1 .)
    identifier      reduce using rule 7 (B -> VAR B_1 .)


state 18

    (11) C -> proc_decl . C
    (10) C -> . empty
    (11) C -> . proc_decl C
    (58) empty -> .
    (18) proc_decl -> . PROCEDURE identifier ( F ) ; block

    BEGIN           reduce using rule 58 (empty -> .)
    PROCEDURE       shift and go to state 21

    proc_decl                      shift and go to state 18
    C                              shift and go to state 26
    empty                          shift and go to state 20

state 19

    (1) program -> A B C . BEGIN D END

    BEGIN           shift and go to state 27


state 20

    (10) C -> empty .

    BEGIN           reduce using rule 10 (C -> empty .)


state 21

    (18) proc_decl -> PROCEDURE . identifier ( F ) ; block

    identifier      shift and go to state 28


state 22

    (16) E -> , identifier . E
    (15) E -> . empty
    (16) E -> . , identifier E
    (58) empty -> .

    ,               shift and go to state 12
    =               reduce using rule 58 (empty -> .)
    :               reduce using rule 58 (empty -> .)

    empty                          shift and go to state 13
    E                              shift and go to state 29

state 23

    (14) const_decl -> identifier E = . integer_constant

    integer_constant shift and go to state 30


state 24

    (9) B_1 -> var_decl B_1 .

    PROCEDURE       reduce using rule 9 (B_1 -> var_decl B_1 .)
    BEGIN           reduce using rule 9 (B_1 -> var_decl B_1 .)
    END             reduce using rule 9 (B_1 -> var_decl B_1 .)
    PRINT           reduce using rule 9 (B_1 -> var_decl B_1 .)
    READ            reduce using rule 9 (B_1 -> var_decl B_1 .)
    IF              reduce using rule 9 (B_1 -> var_decl B_1 .)
    FOR             reduce using rule 9 (B_1 -> var_decl B_1 .)
    RETURN          reduce using rule 9 (B_1 -> var_decl B_1 .)
    CALL            reduce using rule 9 (B_1 -> var_decl B_1 .)
    identifier      reduce using rule 9 (B_1 -> var_decl B_1 .)


state 25

    (17) var_decl -> identifier E . : type

    :               shift and go to state 31


state 26

    (11) C -> proc_decl C .

    BEGIN           reduce using rule 11 (C -> proc_decl C .)


state 27

    (1) program -> A B C BEGIN . D END
    (12) D -> . statement
    (13) D -> . statement D
    (44) statement -> . block
    (45) statement -> . print
    (46) statement -> . read
    (47) statement -> . statement_assign
    (48) statement -> . cond
    (49) statement -> . statement_for
    (50) statement -> . return
    (51) statement -> . call
    (29) block -> . BEGIN A B D END
    (30) block -> . BEGIN A B END
    (31) print -> . PRINT ( string_constant G )
    (34) read -> . READ ( string_constant H )
    (43) statement_assign -> . var assign_op expression
    (37) cond -> . IF bool THEN statement
    (38) cond -> . IF bool THEN statement ELSE statement
    (59) statement_for -> . FOR identifier assign_op TO expression DO statement
    (52) return -> . RETURN
    (39) call -> . CALL identifier ( )
    (40) call -> . CALL identifier ( expression G )
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    BEGIN           shift and go to state 35
    PRINT           shift and go to state 33
    READ            shift and go to state 38
    IF              shift and go to state 42
    FOR             shift and go to state 39
    RETURN          shift and go to state 50
    CALL            shift and go to state 34
    identifier      shift and go to state 37

    statement_for                  shift and go to state 32
    return                         shift and go to state 43
    call                           shift and go to state 49
    block                          shift and go to state 45
    read                           shift and go to state 36
    cond                           shift and go to state 46
    statement_assign               shift and go to state 47
    statement                      shift and go to state 48
    var                            shift and go to state 40
    D                              shift and go to state 44
    print                          shift and go to state 41

state 28

    (18) proc_decl -> PROCEDURE identifier . ( F ) ; block

    (               shift and go to state 51


state 29

    (16) E -> , identifier E .

    =               reduce using rule 16 (E -> , identifier E .)
    :               reduce using rule 16 (E -> , identifier E .)


state 30

    (14) const_decl -> identifier E = integer_constant .

    identifier      reduce using rule 14 (const_decl -> identifier E = integer_constant .)
    VAR             reduce using rule 14 (const_decl -> identifier E = integer_constant .)
    PROCEDURE       reduce using rule 14 (const_decl -> identifier E = integer_constant .)
    BEGIN           reduce using rule 14 (const_decl -> identifier E = integer_constant .)
    END             reduce using rule 14 (const_decl -> identifier E = integer_constant .)
    PRINT           reduce using rule 14 (const_decl -> identifier E = integer_constant .)
    READ            reduce using rule 14 (const_decl -> identifier E = integer_constant .)
    IF              reduce using rule 14 (const_decl -> identifier E = integer_constant .)
    FOR             reduce using rule 14 (const_decl -> identifier E = integer_constant .)
    RETURN          reduce using rule 14 (const_decl -> identifier E = integer_constant .)
    CALL            reduce using rule 14 (const_decl -> identifier E = integer_constant .)


state 31

    (17) var_decl -> identifier E : . type
    (28) type -> . INTEGER

    INTEGER         shift and go to state 53

    type                           shift and go to state 52

state 32

    (49) statement -> statement_for .

    ELSE            reduce using rule 49 (statement -> statement_for .)
    BEGIN           reduce using rule 49 (statement -> statement_for .)
    PRINT           reduce using rule 49 (statement -> statement_for .)
    READ            reduce using rule 49 (statement -> statement_for .)
    IF              reduce using rule 49 (statement -> statement_for .)
    FOR             reduce using rule 49 (statement -> statement_for .)
    RETURN          reduce using rule 49 (statement -> statement_for .)
    CALL            reduce using rule 49 (statement -> statement_for .)
    identifier      reduce using rule 49 (statement -> statement_for .)
    END             reduce using rule 49 (statement -> statement_for .)


state 33

    (31) print -> PRINT . ( string_constant G )

    (               shift and go to state 54


state 34

    (39) call -> CALL . identifier ( )
    (40) call -> CALL . identifier ( expression G )

    identifier      shift and go to state 55


state 35

    (29) block -> BEGIN . A B D END
    (30) block -> BEGIN . A B END
    (2) A -> . empty
    (3) A -> . CONST A_1
    (58) empty -> .

    CONST           shift and go to state 2
    VAR             reduce using rule 58 (empty -> .)
    END             reduce using rule 58 (empty -> .)
    BEGIN           reduce using rule 58 (empty -> .)
    PRINT           reduce using rule 58 (empty -> .)
    READ            reduce using rule 58 (empty -> .)
    IF              reduce using rule 58 (empty -> .)
    FOR             reduce using rule 58 (empty -> .)
    RETURN          reduce using rule 58 (empty -> .)
    CALL            reduce using rule 58 (empty -> .)
    identifier      reduce using rule 58 (empty -> .)

    A                              shift and go to state 56
    empty                          shift and go to state 4

state 36

    (46) statement -> read .

    ELSE            reduce using rule 46 (statement -> read .)
    BEGIN           reduce using rule 46 (statement -> read .)
    PRINT           reduce using rule 46 (statement -> read .)
    READ            reduce using rule 46 (statement -> read .)
    IF              reduce using rule 46 (statement -> read .)
    FOR             reduce using rule 46 (statement -> read .)
    RETURN          reduce using rule 46 (statement -> read .)
    CALL            reduce using rule 46 (statement -> read .)
    identifier      reduce using rule 46 (statement -> read .)
    END             reduce using rule 46 (statement -> read .)


state 37

    (41) var -> identifier .
    (42) var -> identifier . [ expression ]

    assign_op       reduce using rule 41 (var -> identifier .)
    +               reduce using rule 41 (var -> identifier .)
    -               reduce using rule 41 (var -> identifier .)
    *               reduce using rule 41 (var -> identifier .)
    /               reduce using rule 41 (var -> identifier .)
    ,               reduce using rule 41 (var -> identifier .)
    )               reduce using rule 41 (var -> identifier .)
    =               reduce using rule 41 (var -> identifier .)
    less_equal_sign reduce using rule 41 (var -> identifier .)
    >               reduce using rule 41 (var -> identifier .)
    greater_equal_sign reduce using rule 41 (var -> identifier .)
    <               reduce using rule 41 (var -> identifier .)
    not_equal_sign  reduce using rule 41 (var -> identifier .)
    ]               reduce using rule 41 (var -> identifier .)
    BEGIN           reduce using rule 41 (var -> identifier .)
    PRINT           reduce using rule 41 (var -> identifier .)
    READ            reduce using rule 41 (var -> identifier .)
    IF              reduce using rule 41 (var -> identifier .)
    FOR             reduce using rule 41 (var -> identifier .)
    RETURN          reduce using rule 41 (var -> identifier .)
    CALL            reduce using rule 41 (var -> identifier .)
    identifier      reduce using rule 41 (var -> identifier .)
    END             reduce using rule 41 (var -> identifier .)
    ELSE            reduce using rule 41 (var -> identifier .)
    THEN            reduce using rule 41 (var -> identifier .)
    AND             reduce using rule 41 (var -> identifier .)
    OR              reduce using rule 41 (var -> identifier .)
    DO              reduce using rule 41 (var -> identifier .)
    [               shift and go to state 57


state 38

    (34) read -> READ . ( string_constant H )

    (               shift and go to state 58


state 39

    (59) statement_for -> FOR . identifier assign_op TO expression DO statement

    identifier      shift and go to state 59


state 40

    (43) statement_assign -> var . assign_op expression

    assign_op       shift and go to state 60


state 41

    (45) statement -> print .

    ELSE            reduce using rule 45 (statement -> print .)
    BEGIN           reduce using rule 45 (statement -> print .)
    PRINT           reduce using rule 45 (statement -> print .)
    READ            reduce using rule 45 (statement -> print .)
    IF              reduce using rule 45 (statement -> print .)
    FOR             reduce using rule 45 (statement -> print .)
    RETURN          reduce using rule 45 (statement -> print .)
    CALL            reduce using rule 45 (statement -> print .)
    identifier      reduce using rule 45 (statement -> print .)
    END             reduce using rule 45 (statement -> print .)


state 42

    (37) cond -> IF . bool THEN statement
    (38) cond -> IF . bool THEN statement ELSE statement
    (53) bool -> . NOT bool
    (54) bool -> . bool AND bool
    (55) bool -> . bool OR bool
    (56) bool -> . expression relop expression
    (57) bool -> . ( bool )
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    NOT             shift and go to state 63
    (               shift and go to state 61
    integer_constant shift and go to state 62
    -               shift and go to state 66
    identifier      shift and go to state 37

    bool                           shift and go to state 64
    var                            shift and go to state 65
    expression                     shift and go to state 67

state 43

    (50) statement -> return .

    ELSE            reduce using rule 50 (statement -> return .)
    BEGIN           reduce using rule 50 (statement -> return .)
    PRINT           reduce using rule 50 (statement -> return .)
    READ            reduce using rule 50 (statement -> return .)
    IF              reduce using rule 50 (statement -> return .)
    FOR             reduce using rule 50 (statement -> return .)
    RETURN          reduce using rule 50 (statement -> return .)
    CALL            reduce using rule 50 (statement -> return .)
    identifier      reduce using rule 50 (statement -> return .)
    END             reduce using rule 50 (statement -> return .)


state 44

    (1) program -> A B C BEGIN D . END

    END             shift and go to state 68


state 45

    (44) statement -> block .

    ELSE            reduce using rule 44 (statement -> block .)
    BEGIN           reduce using rule 44 (statement -> block .)
    PRINT           reduce using rule 44 (statement -> block .)
    READ            reduce using rule 44 (statement -> block .)
    IF              reduce using rule 44 (statement -> block .)
    FOR             reduce using rule 44 (statement -> block .)
    RETURN          reduce using rule 44 (statement -> block .)
    CALL            reduce using rule 44 (statement -> block .)
    identifier      reduce using rule 44 (statement -> block .)
    END             reduce using rule 44 (statement -> block .)


state 46

    (48) statement -> cond .

    ELSE            reduce using rule 48 (statement -> cond .)
    BEGIN           reduce using rule 48 (statement -> cond .)
    PRINT           reduce using rule 48 (statement -> cond .)
    READ            reduce using rule 48 (statement -> cond .)
    IF              reduce using rule 48 (statement -> cond .)
    FOR             reduce using rule 48 (statement -> cond .)
    RETURN          reduce using rule 48 (statement -> cond .)
    CALL            reduce using rule 48 (statement -> cond .)
    identifier      reduce using rule 48 (statement -> cond .)
    END             reduce using rule 48 (statement -> cond .)


state 47

    (47) statement -> statement_assign .

    ELSE            reduce using rule 47 (statement -> statement_assign .)
    BEGIN           reduce using rule 47 (statement -> statement_assign .)
    PRINT           reduce using rule 47 (statement -> statement_assign .)
    READ            reduce using rule 47 (statement -> statement_assign .)
    IF              reduce using rule 47 (statement -> statement_assign .)
    FOR             reduce using rule 47 (statement -> statement_assign .)
    RETURN          reduce using rule 47 (statement -> statement_assign .)
    CALL            reduce using rule 47 (statement -> statement_assign .)
    identifier      reduce using rule 47 (statement -> statement_assign .)
    END             reduce using rule 47 (statement -> statement_assign .)


state 48

    (12) D -> statement .
    (13) D -> statement . D
    (12) D -> . statement
    (13) D -> . statement D
    (44) statement -> . block
    (45) statement -> . print
    (46) statement -> . read
    (47) statement -> . statement_assign
    (48) statement -> . cond
    (49) statement -> . statement_for
    (50) statement -> . return
    (51) statement -> . call
    (29) block -> . BEGIN A B D END
    (30) block -> . BEGIN A B END
    (31) print -> . PRINT ( string_constant G )
    (34) read -> . READ ( string_constant H )
    (43) statement_assign -> . var assign_op expression
    (37) cond -> . IF bool THEN statement
    (38) cond -> . IF bool THEN statement ELSE statement
    (59) statement_for -> . FOR identifier assign_op TO expression DO statement
    (52) return -> . RETURN
    (39) call -> . CALL identifier ( )
    (40) call -> . CALL identifier ( expression G )
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    END             reduce using rule 12 (D -> statement .)
    BEGIN           shift and go to state 35
    PRINT           shift and go to state 33
    READ            shift and go to state 38
    IF              shift and go to state 42
    FOR             shift and go to state 39
    RETURN          shift and go to state 50
    CALL            shift and go to state 34
    identifier      shift and go to state 37

    statement_for                  shift and go to state 32
    return                         shift and go to state 43
    D                              shift and go to state 69
    block                          shift and go to state 45
    read                           shift and go to state 36
    cond                           shift and go to state 46
    statement_assign               shift and go to state 47
    statement                      shift and go to state 48
    var                            shift and go to state 40
    call                           shift and go to state 49
    print                          shift and go to state 41

state 49

    (51) statement -> call .

    ELSE            reduce using rule 51 (statement -> call .)
    BEGIN           reduce using rule 51 (statement -> call .)
    PRINT           reduce using rule 51 (statement -> call .)
    READ            reduce using rule 51 (statement -> call .)
    IF              reduce using rule 51 (statement -> call .)
    FOR             reduce using rule 51 (statement -> call .)
    RETURN          reduce using rule 51 (statement -> call .)
    CALL            reduce using rule 51 (statement -> call .)
    identifier      reduce using rule 51 (statement -> call .)
    END             reduce using rule 51 (statement -> call .)


state 50

    (52) return -> RETURN .

    ELSE            reduce using rule 52 (return -> RETURN .)
    BEGIN           reduce using rule 52 (return -> RETURN .)
    PRINT           reduce using rule 52 (return -> RETURN .)
    READ            reduce using rule 52 (return -> RETURN .)
    IF              reduce using rule 52 (return -> RETURN .)
    FOR             reduce using rule 52 (return -> RETURN .)
    RETURN          reduce using rule 52 (return -> RETURN .)
    CALL            reduce using rule 52 (return -> RETURN .)
    identifier      reduce using rule 52 (return -> RETURN .)
    END             reduce using rule 52 (return -> RETURN .)


state 51

    (18) proc_decl -> PROCEDURE identifier ( . F ) ; block
    (19) F -> . empty
    (20) F -> . format F_1
    (58) empty -> .
    (23) format -> . identifier E : type
    (24) format -> . identifier E : mode type

    )               reduce using rule 58 (empty -> .)
    identifier      shift and go to state 70

    F                              shift and go to state 73
    format                         shift and go to state 71
    empty                          shift and go to state 72

state 52

    (17) var_decl -> identifier E : type .

    identifier      reduce using rule 17 (var_decl -> identifier E : type .)
    PROCEDURE       reduce using rule 17 (var_decl -> identifier E : type .)
    BEGIN           reduce using rule 17 (var_decl -> identifier E : type .)
    END             reduce using rule 17 (var_decl -> identifier E : type .)
    PRINT           reduce using rule 17 (var_decl -> identifier E : type .)
    READ            reduce using rule 17 (var_decl -> identifier E : type .)
    IF              reduce using rule 17 (var_decl -> identifier E : type .)
    FOR             reduce using rule 17 (var_decl -> identifier E : type .)
    RETURN          reduce using rule 17 (var_decl -> identifier E : type .)
    CALL            reduce using rule 17 (var_decl -> identifier E : type .)


state 53

    (28) type -> INTEGER .

    ;               reduce using rule 28 (type -> INTEGER .)
    )               reduce using rule 28 (type -> INTEGER .)
    identifier      reduce using rule 28 (type -> INTEGER .)
    PROCEDURE       reduce using rule 28 (type -> INTEGER .)
    BEGIN           reduce using rule 28 (type -> INTEGER .)
    END             reduce using rule 28 (type -> INTEGER .)
    PRINT           reduce using rule 28 (type -> INTEGER .)
    READ            reduce using rule 28 (type -> INTEGER .)
    IF              reduce using rule 28 (type -> INTEGER .)
    FOR             reduce using rule 28 (type -> INTEGER .)
    RETURN          reduce using rule 28 (type -> INTEGER .)
    CALL            reduce using rule 28 (type -> INTEGER .)


state 54

    (31) print -> PRINT ( . string_constant G )

    string_constant shift and go to state 74


state 55

    (39) call -> CALL identifier . ( )
    (40) call -> CALL identifier . ( expression G )

    (               shift and go to state 75


state 56

    (29) block -> BEGIN A . B D END
    (30) block -> BEGIN A . B END
    (6) B -> . empty
    (7) B -> . VAR B_1
    (58) empty -> .

    VAR             shift and go to state 8
    END             reduce using rule 58 (empty -> .)
    BEGIN           reduce using rule 58 (empty -> .)
    PRINT           reduce using rule 58 (empty -> .)
    READ            reduce using rule 58 (empty -> .)
    IF              reduce using rule 58 (empty -> .)
    FOR             reduce using rule 58 (empty -> .)
    RETURN          reduce using rule 58 (empty -> .)
    CALL            reduce using rule 58 (empty -> .)
    identifier      reduce using rule 58 (empty -> .)

    B                              shift and go to state 76
    empty                          shift and go to state 10

state 57

    (42) var -> identifier [ . expression ]
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    integer_constant shift and go to state 62
    -               shift and go to state 66
    (               shift and go to state 77
    identifier      shift and go to state 37

    var                            shift and go to state 65
    expression                     shift and go to state 78

state 58

    (34) read -> READ ( . string_constant H )

    string_constant shift and go to state 79


state 59

    (59) statement_for -> FOR identifier . assign_op TO expression DO statement

    assign_op       shift and go to state 80


state 60

    (43) statement_assign -> var assign_op . expression
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    integer_constant shift and go to state 62
    -               shift and go to state 66
    (               shift and go to state 77
    identifier      shift and go to state 37

    var                            shift and go to state 65
    expression                     shift and go to state 81

state 61

    (57) bool -> ( . bool )
    (72) expression -> ( . expression )
    (53) bool -> . NOT bool
    (54) bool -> . bool AND bool
    (55) bool -> . bool OR bool
    (56) bool -> . expression relop expression
    (57) bool -> . ( bool )
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    NOT             shift and go to state 63
    (               shift and go to state 61
    integer_constant shift and go to state 62
    -               shift and go to state 66
    identifier      shift and go to state 37

    bool                           shift and go to state 82
    var                            shift and go to state 65
    expression                     shift and go to state 83

state 62

    (66) expression -> integer_constant .

    ]               reduce using rule 66 (expression -> integer_constant .)
    +               reduce using rule 66 (expression -> integer_constant .)
    -               reduce using rule 66 (expression -> integer_constant .)
    *               reduce using rule 66 (expression -> integer_constant .)
    /               reduce using rule 66 (expression -> integer_constant .)
    =               reduce using rule 66 (expression -> integer_constant .)
    less_equal_sign reduce using rule 66 (expression -> integer_constant .)
    >               reduce using rule 66 (expression -> integer_constant .)
    greater_equal_sign reduce using rule 66 (expression -> integer_constant .)
    <               reduce using rule 66 (expression -> integer_constant .)
    not_equal_sign  reduce using rule 66 (expression -> integer_constant .)
    )               reduce using rule 66 (expression -> integer_constant .)
    BEGIN           reduce using rule 66 (expression -> integer_constant .)
    PRINT           reduce using rule 66 (expression -> integer_constant .)
    READ            reduce using rule 66 (expression -> integer_constant .)
    IF              reduce using rule 66 (expression -> integer_constant .)
    FOR             reduce using rule 66 (expression -> integer_constant .)
    RETURN          reduce using rule 66 (expression -> integer_constant .)
    CALL            reduce using rule 66 (expression -> integer_constant .)
    identifier      reduce using rule 66 (expression -> integer_constant .)
    END             reduce using rule 66 (expression -> integer_constant .)
    ELSE            reduce using rule 66 (expression -> integer_constant .)
    ,               reduce using rule 66 (expression -> integer_constant .)
    THEN            reduce using rule 66 (expression -> integer_constant .)
    AND             reduce using rule 66 (expression -> integer_constant .)
    OR              reduce using rule 66 (expression -> integer_constant .)
    DO              reduce using rule 66 (expression -> integer_constant .)


state 63

    (53) bool -> NOT . bool
    (53) bool -> . NOT bool
    (54) bool -> . bool AND bool
    (55) bool -> . bool OR bool
    (56) bool -> . expression relop expression
    (57) bool -> . ( bool )
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    NOT             shift and go to state 63
    (               shift and go to state 61
    integer_constant shift and go to state 62
    -               shift and go to state 66
    identifier      shift and go to state 37

    bool                           shift and go to state 84
    var                            shift and go to state 65
    expression                     shift and go to state 67

state 64

    (37) cond -> IF bool . THEN statement
    (38) cond -> IF bool . THEN statement ELSE statement
    (54) bool -> bool . AND bool
    (55) bool -> bool . OR bool

    THEN            shift and go to state 86
    AND             shift and go to state 85
    OR              shift and go to state 87


state 65

    (73) expression -> var .

    ]               reduce using rule 73 (expression -> var .)
    +               reduce using rule 73 (expression -> var .)
    -               reduce using rule 73 (expression -> var .)
    *               reduce using rule 73 (expression -> var .)
    /               reduce using rule 73 (expression -> var .)
    =               reduce using rule 73 (expression -> var .)
    less_equal_sign reduce using rule 73 (expression -> var .)
    >               reduce using rule 73 (expression -> var .)
    greater_equal_sign reduce using rule 73 (expression -> var .)
    <               reduce using rule 73 (expression -> var .)
    not_equal_sign  reduce using rule 73 (expression -> var .)
    )               reduce using rule 73 (expression -> var .)
    BEGIN           reduce using rule 73 (expression -> var .)
    PRINT           reduce using rule 73 (expression -> var .)
    READ            reduce using rule 73 (expression -> var .)
    IF              reduce using rule 73 (expression -> var .)
    FOR             reduce using rule 73 (expression -> var .)
    RETURN          reduce using rule 73 (expression -> var .)
    CALL            reduce using rule 73 (expression -> var .)
    identifier      reduce using rule 73 (expression -> var .)
    END             reduce using rule 73 (expression -> var .)
    ELSE            reduce using rule 73 (expression -> var .)
    ,               reduce using rule 73 (expression -> var .)
    THEN            reduce using rule 73 (expression -> var .)
    AND             reduce using rule 73 (expression -> var .)
    OR              reduce using rule 73 (expression -> var .)
    DO              reduce using rule 73 (expression -> var .)


state 66

    (71) expression -> - . expression
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    integer_constant shift and go to state 62
    -               shift and go to state 66
    (               shift and go to state 77
    identifier      shift and go to state 37

    var                            shift and go to state 65
    expression                     shift and go to state 88

state 67

    (56) bool -> expression . relop expression
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression
    (60) relop -> . =
    (61) relop -> . less_equal_sign
    (62) relop -> . >
    (63) relop -> . greater_equal_sign
    (64) relop -> . <
    (65) relop -> . not_equal_sign

    +               shift and go to state 95
    -               shift and go to state 98
    *               shift and go to state 92
    /               shift and go to state 93
    =               shift and go to state 96
    less_equal_sign shift and go to state 94
    >               shift and go to state 91
    greater_equal_sign shift and go to state 89
    <               shift and go to state 90
    not_equal_sign  shift and go to state 99

    relop                          shift and go to state 97

state 68

    (1) program -> A B C BEGIN D END .

    $end            reduce using rule 1 (program -> A B C BEGIN D END .)


state 69

    (13) D -> statement D .

    END             reduce using rule 13 (D -> statement D .)


state 70

    (23) format -> identifier . E : type
    (24) format -> identifier . E : mode type
    (15) E -> . empty
    (16) E -> . , identifier E
    (58) empty -> .

    ,               shift and go to state 12
    :               reduce using rule 58 (empty -> .)

    empty                          shift and go to state 13
    E                              shift and go to state 100

state 71

    (20) F -> format . F_1
    (21) F_1 -> . empty
    (22) F_1 -> . ; format F_1
    (58) empty -> .

    ;               shift and go to state 102
    )               reduce using rule 58 (empty -> .)

    F_1                            shift and go to state 101
    empty                          shift and go to state 103

state 72

    (19) F -> empty .

    )               reduce using rule 19 (F -> empty .)


state 73

    (18) proc_decl -> PROCEDURE identifier ( F . ) ; block

    )               shift and go to state 104


state 74

    (31) print -> PRINT ( string_constant . G )
    (32) G -> . empty
    (33) G -> . , expression G
    (58) empty -> .

    ,               shift and go to state 105
    )               reduce using rule 58 (empty -> .)

    G                              shift and go to state 107
    empty                          shift and go to state 106

state 75

    (39) call -> CALL identifier ( . )
    (40) call -> CALL identifier ( . expression G )
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    )               shift and go to state 108
    integer_constant shift and go to state 62
    -               shift and go to state 66
    (               shift and go to state 77
    identifier      shift and go to state 37

    var                            shift and go to state 65
    expression                     shift and go to state 109

state 76

    (29) block -> BEGIN A B . D END
    (30) block -> BEGIN A B . END
    (12) D -> . statement
    (13) D -> . statement D
    (44) statement -> . block
    (45) statement -> . print
    (46) statement -> . read
    (47) statement -> . statement_assign
    (48) statement -> . cond
    (49) statement -> . statement_for
    (50) statement -> . return
    (51) statement -> . call
    (29) block -> . BEGIN A B D END
    (30) block -> . BEGIN A B END
    (31) print -> . PRINT ( string_constant G )
    (34) read -> . READ ( string_constant H )
    (43) statement_assign -> . var assign_op expression
    (37) cond -> . IF bool THEN statement
    (38) cond -> . IF bool THEN statement ELSE statement
    (59) statement_for -> . FOR identifier assign_op TO expression DO statement
    (52) return -> . RETURN
    (39) call -> . CALL identifier ( )
    (40) call -> . CALL identifier ( expression G )
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    END             shift and go to state 110
    BEGIN           shift and go to state 35
    PRINT           shift and go to state 33
    READ            shift and go to state 38
    IF              shift and go to state 42
    FOR             shift and go to state 39
    RETURN          shift and go to state 50
    CALL            shift and go to state 34
    identifier      shift and go to state 37

    statement_for                  shift and go to state 32
    return                         shift and go to state 43
    call                           shift and go to state 49
    block                          shift and go to state 45
    read                           shift and go to state 36
    cond                           shift and go to state 46
    statement_assign               shift and go to state 47
    statement                      shift and go to state 48
    var                            shift and go to state 40
    D                              shift and go to state 111
    print                          shift and go to state 41

state 77

    (72) expression -> ( . expression )
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    integer_constant shift and go to state 62
    -               shift and go to state 66
    (               shift and go to state 77
    identifier      shift and go to state 37

    var                            shift and go to state 65
    expression                     shift and go to state 112

state 78

    (42) var -> identifier [ expression . ]
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression

    ]               shift and go to state 113
    +               shift and go to state 95
    -               shift and go to state 98
    *               shift and go to state 92
    /               shift and go to state 93


state 79

    (34) read -> READ ( string_constant . H )
    (35) H -> . empty
    (36) H -> . , var H
    (58) empty -> .

    ,               shift and go to state 115
    )               reduce using rule 58 (empty -> .)

    H                              shift and go to state 114
    empty                          shift and go to state 116

state 80

    (59) statement_for -> FOR identifier assign_op . TO expression DO statement

    TO              shift and go to state 117


state 81

    (43) statement_assign -> var assign_op expression .
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression

    BEGIN           reduce using rule 43 (statement_assign -> var assign_op expression .)
    PRINT           reduce using rule 43 (statement_assign -> var assign_op expression .)
    READ            reduce using rule 43 (statement_assign -> var assign_op expression .)
    IF              reduce using rule 43 (statement_assign -> var assign_op expression .)
    FOR             reduce using rule 43 (statement_assign -> var assign_op expression .)
    RETURN          reduce using rule 43 (statement_assign -> var assign_op expression .)
    CALL            reduce using rule 43 (statement_assign -> var assign_op expression .)
    identifier      reduce using rule 43 (statement_assign -> var assign_op expression .)
    END             reduce using rule 43 (statement_assign -> var assign_op expression .)
    ELSE            reduce using rule 43 (statement_assign -> var assign_op expression .)
    +               shift and go to state 95
    -               shift and go to state 98
    *               shift and go to state 92
    /               shift and go to state 93


state 82

    (57) bool -> ( bool . )
    (54) bool -> bool . AND bool
    (55) bool -> bool . OR bool

    )               shift and go to state 118
    AND             shift and go to state 85
    OR              shift and go to state 87


state 83

    (72) expression -> ( expression . )
    (56) bool -> expression . relop expression
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression
    (60) relop -> . =
    (61) relop -> . less_equal_sign
    (62) relop -> . >
    (63) relop -> . greater_equal_sign
    (64) relop -> . <
    (65) relop -> . not_equal_sign

    )               shift and go to state 119
    +               shift and go to state 95
    -               shift and go to state 98
    *               shift and go to state 92
    /               shift and go to state 93
    =               shift and go to state 96
    less_equal_sign shift and go to state 94
    >               shift and go to state 91
    greater_equal_sign shift and go to state 89
    <               shift and go to state 90
    not_equal_sign  shift and go to state 99

    relop                          shift and go to state 97

state 84

    (53) bool -> NOT bool .
    (54) bool -> bool . AND bool
    (55) bool -> bool . OR bool

    THEN            reduce using rule 53 (bool -> NOT bool .)
    AND             reduce using rule 53 (bool -> NOT bool .)
    OR              reduce using rule 53 (bool -> NOT bool .)
    )               reduce using rule 53 (bool -> NOT bool .)

  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 87 ]


state 85

    (54) bool -> bool AND . bool
    (53) bool -> . NOT bool
    (54) bool -> . bool AND bool
    (55) bool -> . bool OR bool
    (56) bool -> . expression relop expression
    (57) bool -> . ( bool )
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    NOT             shift and go to state 63
    (               shift and go to state 61
    integer_constant shift and go to state 62
    -               shift and go to state 66
    identifier      shift and go to state 37

    bool                           shift and go to state 120
    var                            shift and go to state 65
    expression                     shift and go to state 67

state 86

    (37) cond -> IF bool THEN . statement
    (38) cond -> IF bool THEN . statement ELSE statement
    (44) statement -> . block
    (45) statement -> . print
    (46) statement -> . read
    (47) statement -> . statement_assign
    (48) statement -> . cond
    (49) statement -> . statement_for
    (50) statement -> . return
    (51) statement -> . call
    (29) block -> . BEGIN A B D END
    (30) block -> . BEGIN A B END
    (31) print -> . PRINT ( string_constant G )
    (34) read -> . READ ( string_constant H )
    (43) statement_assign -> . var assign_op expression
    (37) cond -> . IF bool THEN statement
    (38) cond -> . IF bool THEN statement ELSE statement
    (59) statement_for -> . FOR identifier assign_op TO expression DO statement
    (52) return -> . RETURN
    (39) call -> . CALL identifier ( )
    (40) call -> . CALL identifier ( expression G )
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    BEGIN           shift and go to state 35
    PRINT           shift and go to state 33
    READ            shift and go to state 38
    IF              shift and go to state 42
    FOR             shift and go to state 39
    RETURN          shift and go to state 50
    CALL            shift and go to state 34
    identifier      shift and go to state 37

    statement_for                  shift and go to state 32
    return                         shift and go to state 43
    block                          shift and go to state 45
    read                           shift and go to state 36
    cond                           shift and go to state 46
    statement_assign               shift and go to state 47
    statement                      shift and go to state 121
    var                            shift and go to state 40
    call                           shift and go to state 49
    print                          shift and go to state 41

state 87

    (55) bool -> bool OR . bool
    (53) bool -> . NOT bool
    (54) bool -> . bool AND bool
    (55) bool -> . bool OR bool
    (56) bool -> . expression relop expression
    (57) bool -> . ( bool )
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    NOT             shift and go to state 63
    (               shift and go to state 61
    integer_constant shift and go to state 62
    -               shift and go to state 66
    identifier      shift and go to state 37

    bool                           shift and go to state 122
    var                            shift and go to state 65
    expression                     shift and go to state 67

state 88

    (71) expression -> - expression .
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression

    ]               reduce using rule 71 (expression -> - expression .)
    +               reduce using rule 71 (expression -> - expression .)
    -               reduce using rule 71 (expression -> - expression .)
    *               reduce using rule 71 (expression -> - expression .)
    /               reduce using rule 71 (expression -> - expression .)
    =               reduce using rule 71 (expression -> - expression .)
    less_equal_sign reduce using rule 71 (expression -> - expression .)
    >               reduce using rule 71 (expression -> - expression .)
    greater_equal_sign reduce using rule 71 (expression -> - expression .)
    <               reduce using rule 71 (expression -> - expression .)
    not_equal_sign  reduce using rule 71 (expression -> - expression .)
    )               reduce using rule 71 (expression -> - expression .)
    BEGIN           reduce using rule 71 (expression -> - expression .)
    PRINT           reduce using rule 71 (expression -> - expression .)
    READ            reduce using rule 71 (expression -> - expression .)
    IF              reduce using rule 71 (expression -> - expression .)
    FOR             reduce using rule 71 (expression -> - expression .)
    RETURN          reduce using rule 71 (expression -> - expression .)
    CALL            reduce using rule 71 (expression -> - expression .)
    identifier      reduce using rule 71 (expression -> - expression .)
    END             reduce using rule 71 (expression -> - expression .)
    ELSE            reduce using rule 71 (expression -> - expression .)
    ,               reduce using rule 71 (expression -> - expression .)
    THEN            reduce using rule 71 (expression -> - expression .)
    AND             reduce using rule 71 (expression -> - expression .)
    OR              reduce using rule 71 (expression -> - expression .)
    DO              reduce using rule 71 (expression -> - expression .)

  ! +               [ shift and go to state 95 ]
  ! -               [ shift and go to state 98 ]
  ! *               [ shift and go to state 92 ]
  ! /               [ shift and go to state 93 ]


state 89

    (63) relop -> greater_equal_sign .

    integer_constant reduce using rule 63 (relop -> greater_equal_sign .)
    -               reduce using rule 63 (relop -> greater_equal_sign .)
    (               reduce using rule 63 (relop -> greater_equal_sign .)
    identifier      reduce using rule 63 (relop -> greater_equal_sign .)


state 90

    (64) relop -> < .

    integer_constant reduce using rule 64 (relop -> < .)
    -               reduce using rule 64 (relop -> < .)
    (               reduce using rule 64 (relop -> < .)
    identifier      reduce using rule 64 (relop -> < .)


state 91

    (62) relop -> > .

    integer_constant reduce using rule 62 (relop -> > .)
    -               reduce using rule 62 (relop -> > .)
    (               reduce using rule 62 (relop -> > .)
    identifier      reduce using rule 62 (relop -> > .)


state 92

    (69) expression -> expression * . expression
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    integer_constant shift and go to state 62
    -               shift and go to state 66
    (               shift and go to state 77
    identifier      shift and go to state 37

    var                            shift and go to state 65
    expression                     shift and go to state 123

state 93

    (70) expression -> expression / . expression
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    integer_constant shift and go to state 62
    -               shift and go to state 66
    (               shift and go to state 77
    identifier      shift and go to state 37

    var                            shift and go to state 65
    expression                     shift and go to state 124

state 94

    (61) relop -> less_equal_sign .

    integer_constant reduce using rule 61 (relop -> less_equal_sign .)
    -               reduce using rule 61 (relop -> less_equal_sign .)
    (               reduce using rule 61 (relop -> less_equal_sign .)
    identifier      reduce using rule 61 (relop -> less_equal_sign .)


state 95

    (67) expression -> expression + . expression
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    integer_constant shift and go to state 62
    -               shift and go to state 66
    (               shift and go to state 77
    identifier      shift and go to state 37

    var                            shift and go to state 65
    expression                     shift and go to state 125

state 96

    (60) relop -> = .

    integer_constant reduce using rule 60 (relop -> = .)
    -               reduce using rule 60 (relop -> = .)
    (               reduce using rule 60 (relop -> = .)
    identifier      reduce using rule 60 (relop -> = .)


state 97

    (56) bool -> expression relop . expression
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    integer_constant shift and go to state 62
    -               shift and go to state 66
    (               shift and go to state 77
    identifier      shift and go to state 37

    var                            shift and go to state 65
    expression                     shift and go to state 126

state 98

    (68) expression -> expression - . expression
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    integer_constant shift and go to state 62
    -               shift and go to state 66
    (               shift and go to state 77
    identifier      shift and go to state 37

    var                            shift and go to state 65
    expression                     shift and go to state 127

state 99

    (65) relop -> not_equal_sign .

    integer_constant reduce using rule 65 (relop -> not_equal_sign .)
    -               reduce using rule 65 (relop -> not_equal_sign .)
    (               reduce using rule 65 (relop -> not_equal_sign .)
    identifier      reduce using rule 65 (relop -> not_equal_sign .)


state 100

    (23) format -> identifier E . : type
    (24) format -> identifier E . : mode type

    :               shift and go to state 128


state 101

    (20) F -> format F_1 .

    )               reduce using rule 20 (F -> format F_1 .)


state 102

    (22) F_1 -> ; . format F_1
    (23) format -> . identifier E : type
    (24) format -> . identifier E : mode type

    identifier      shift and go to state 70

    format                         shift and go to state 129

state 103

    (21) F_1 -> empty .

    )               reduce using rule 21 (F_1 -> empty .)


state 104

    (18) proc_decl -> PROCEDURE identifier ( F ) . ; block

    ;               shift and go to state 130


state 105

    (33) G -> , . expression G
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    integer_constant shift and go to state 62
    -               shift and go to state 66
    (               shift and go to state 77
    identifier      shift and go to state 37

    var                            shift and go to state 65
    expression                     shift and go to state 131

state 106

    (32) G -> empty .

    )               reduce using rule 32 (G -> empty .)


state 107

    (31) print -> PRINT ( string_constant G . )

    )               shift and go to state 132


state 108

    (39) call -> CALL identifier ( ) .

    BEGIN           reduce using rule 39 (call -> CALL identifier ( ) .)
    PRINT           reduce using rule 39 (call -> CALL identifier ( ) .)
    READ            reduce using rule 39 (call -> CALL identifier ( ) .)
    IF              reduce using rule 39 (call -> CALL identifier ( ) .)
    FOR             reduce using rule 39 (call -> CALL identifier ( ) .)
    RETURN          reduce using rule 39 (call -> CALL identifier ( ) .)
    CALL            reduce using rule 39 (call -> CALL identifier ( ) .)
    identifier      reduce using rule 39 (call -> CALL identifier ( ) .)
    END             reduce using rule 39 (call -> CALL identifier ( ) .)
    ELSE            reduce using rule 39 (call -> CALL identifier ( ) .)


state 109

    (40) call -> CALL identifier ( expression . G )
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression
    (32) G -> . empty
    (33) G -> . , expression G
    (58) empty -> .

    +               shift and go to state 95
    -               shift and go to state 98
    *               shift and go to state 92
    /               shift and go to state 93
    ,               shift and go to state 105
    )               reduce using rule 58 (empty -> .)

    G                              shift and go to state 133
    empty                          shift and go to state 106

state 110

    (30) block -> BEGIN A B END .

    ELSE            reduce using rule 30 (block -> BEGIN A B END .)
    BEGIN           reduce using rule 30 (block -> BEGIN A B END .)
    PRINT           reduce using rule 30 (block -> BEGIN A B END .)
    READ            reduce using rule 30 (block -> BEGIN A B END .)
    IF              reduce using rule 30 (block -> BEGIN A B END .)
    FOR             reduce using rule 30 (block -> BEGIN A B END .)
    RETURN          reduce using rule 30 (block -> BEGIN A B END .)
    CALL            reduce using rule 30 (block -> BEGIN A B END .)
    identifier      reduce using rule 30 (block -> BEGIN A B END .)
    END             reduce using rule 30 (block -> BEGIN A B END .)
    PROCEDURE       reduce using rule 30 (block -> BEGIN A B END .)


state 111

    (29) block -> BEGIN A B D . END

    END             shift and go to state 134


state 112

    (72) expression -> ( expression . )
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression

    )               shift and go to state 119
    +               shift and go to state 95
    -               shift and go to state 98
    *               shift and go to state 92
    /               shift and go to state 93


state 113

    (42) var -> identifier [ expression ] .

    assign_op       reduce using rule 42 (var -> identifier [ expression ] .)
    +               reduce using rule 42 (var -> identifier [ expression ] .)
    -               reduce using rule 42 (var -> identifier [ expression ] .)
    *               reduce using rule 42 (var -> identifier [ expression ] .)
    /               reduce using rule 42 (var -> identifier [ expression ] .)
    ,               reduce using rule 42 (var -> identifier [ expression ] .)
    )               reduce using rule 42 (var -> identifier [ expression ] .)
    =               reduce using rule 42 (var -> identifier [ expression ] .)
    less_equal_sign reduce using rule 42 (var -> identifier [ expression ] .)
    >               reduce using rule 42 (var -> identifier [ expression ] .)
    greater_equal_sign reduce using rule 42 (var -> identifier [ expression ] .)
    <               reduce using rule 42 (var -> identifier [ expression ] .)
    not_equal_sign  reduce using rule 42 (var -> identifier [ expression ] .)
    ]               reduce using rule 42 (var -> identifier [ expression ] .)
    BEGIN           reduce using rule 42 (var -> identifier [ expression ] .)
    PRINT           reduce using rule 42 (var -> identifier [ expression ] .)
    READ            reduce using rule 42 (var -> identifier [ expression ] .)
    IF              reduce using rule 42 (var -> identifier [ expression ] .)
    FOR             reduce using rule 42 (var -> identifier [ expression ] .)
    RETURN          reduce using rule 42 (var -> identifier [ expression ] .)
    CALL            reduce using rule 42 (var -> identifier [ expression ] .)
    identifier      reduce using rule 42 (var -> identifier [ expression ] .)
    END             reduce using rule 42 (var -> identifier [ expression ] .)
    ELSE            reduce using rule 42 (var -> identifier [ expression ] .)
    THEN            reduce using rule 42 (var -> identifier [ expression ] .)
    AND             reduce using rule 42 (var -> identifier [ expression ] .)
    OR              reduce using rule 42 (var -> identifier [ expression ] .)
    DO              reduce using rule 42 (var -> identifier [ expression ] .)


state 114

    (34) read -> READ ( string_constant H . )

    )               shift and go to state 135


state 115

    (36) H -> , . var H
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    identifier      shift and go to state 37

    var                            shift and go to state 136

state 116

    (35) H -> empty .

    )               reduce using rule 35 (H -> empty .)


state 117

    (59) statement_for -> FOR identifier assign_op TO . expression DO statement
    (66) expression -> . integer_constant
    (67) expression -> . expression + expression
    (68) expression -> . expression - expression
    (69) expression -> . expression * expression
    (70) expression -> . expression / expression
    (71) expression -> . - expression
    (72) expression -> . ( expression )
    (73) expression -> . var
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    integer_constant shift and go to state 62
    -               shift and go to state 66
    (               shift and go to state 77
    identifier      shift and go to state 37

    var                            shift and go to state 65
    expression                     shift and go to state 137

state 118

    (57) bool -> ( bool ) .

    THEN            reduce using rule 57 (bool -> ( bool ) .)
    AND             reduce using rule 57 (bool -> ( bool ) .)
    OR              reduce using rule 57 (bool -> ( bool ) .)
    )               reduce using rule 57 (bool -> ( bool ) .)


state 119

    (72) expression -> ( expression ) .

    ]               reduce using rule 72 (expression -> ( expression ) .)
    +               reduce using rule 72 (expression -> ( expression ) .)
    -               reduce using rule 72 (expression -> ( expression ) .)
    *               reduce using rule 72 (expression -> ( expression ) .)
    /               reduce using rule 72 (expression -> ( expression ) .)
    =               reduce using rule 72 (expression -> ( expression ) .)
    less_equal_sign reduce using rule 72 (expression -> ( expression ) .)
    >               reduce using rule 72 (expression -> ( expression ) .)
    greater_equal_sign reduce using rule 72 (expression -> ( expression ) .)
    <               reduce using rule 72 (expression -> ( expression ) .)
    not_equal_sign  reduce using rule 72 (expression -> ( expression ) .)
    )               reduce using rule 72 (expression -> ( expression ) .)
    BEGIN           reduce using rule 72 (expression -> ( expression ) .)
    PRINT           reduce using rule 72 (expression -> ( expression ) .)
    READ            reduce using rule 72 (expression -> ( expression ) .)
    IF              reduce using rule 72 (expression -> ( expression ) .)
    FOR             reduce using rule 72 (expression -> ( expression ) .)
    RETURN          reduce using rule 72 (expression -> ( expression ) .)
    CALL            reduce using rule 72 (expression -> ( expression ) .)
    identifier      reduce using rule 72 (expression -> ( expression ) .)
    END             reduce using rule 72 (expression -> ( expression ) .)
    ELSE            reduce using rule 72 (expression -> ( expression ) .)
    ,               reduce using rule 72 (expression -> ( expression ) .)
    THEN            reduce using rule 72 (expression -> ( expression ) .)
    AND             reduce using rule 72 (expression -> ( expression ) .)
    OR              reduce using rule 72 (expression -> ( expression ) .)
    DO              reduce using rule 72 (expression -> ( expression ) .)


state 120

    (54) bool -> bool AND bool .
    (54) bool -> bool . AND bool
    (55) bool -> bool . OR bool

    THEN            reduce using rule 54 (bool -> bool AND bool .)
    AND             reduce using rule 54 (bool -> bool AND bool .)
    OR              reduce using rule 54 (bool -> bool AND bool .)
    )               reduce using rule 54 (bool -> bool AND bool .)

  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 87 ]


state 121

    (37) cond -> IF bool THEN statement .
    (38) cond -> IF bool THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    BEGIN           reduce using rule 37 (cond -> IF bool THEN statement .)
    PRINT           reduce using rule 37 (cond -> IF bool THEN statement .)
    READ            reduce using rule 37 (cond -> IF bool THEN statement .)
    IF              reduce using rule 37 (cond -> IF bool THEN statement .)
    FOR             reduce using rule 37 (cond -> IF bool THEN statement .)
    RETURN          reduce using rule 37 (cond -> IF bool THEN statement .)
    CALL            reduce using rule 37 (cond -> IF bool THEN statement .)
    identifier      reduce using rule 37 (cond -> IF bool THEN statement .)
    END             reduce using rule 37 (cond -> IF bool THEN statement .)
    ELSE            shift and go to state 138

  ! ELSE            [ reduce using rule 37 (cond -> IF bool THEN statement .) ]


state 122

    (55) bool -> bool OR bool .
    (54) bool -> bool . AND bool
    (55) bool -> bool . OR bool

    THEN            reduce using rule 55 (bool -> bool OR bool .)
    AND             reduce using rule 55 (bool -> bool OR bool .)
    OR              reduce using rule 55 (bool -> bool OR bool .)
    )               reduce using rule 55 (bool -> bool OR bool .)

  ! AND             [ shift and go to state 85 ]
  ! OR              [ shift and go to state 87 ]


state 123

    (69) expression -> expression * expression .
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression

    ]               reduce using rule 69 (expression -> expression * expression .)
    +               reduce using rule 69 (expression -> expression * expression .)
    -               reduce using rule 69 (expression -> expression * expression .)
    *               reduce using rule 69 (expression -> expression * expression .)
    /               reduce using rule 69 (expression -> expression * expression .)
    =               reduce using rule 69 (expression -> expression * expression .)
    less_equal_sign reduce using rule 69 (expression -> expression * expression .)
    >               reduce using rule 69 (expression -> expression * expression .)
    greater_equal_sign reduce using rule 69 (expression -> expression * expression .)
    <               reduce using rule 69 (expression -> expression * expression .)
    not_equal_sign  reduce using rule 69 (expression -> expression * expression .)
    )               reduce using rule 69 (expression -> expression * expression .)
    BEGIN           reduce using rule 69 (expression -> expression * expression .)
    PRINT           reduce using rule 69 (expression -> expression * expression .)
    READ            reduce using rule 69 (expression -> expression * expression .)
    IF              reduce using rule 69 (expression -> expression * expression .)
    FOR             reduce using rule 69 (expression -> expression * expression .)
    RETURN          reduce using rule 69 (expression -> expression * expression .)
    CALL            reduce using rule 69 (expression -> expression * expression .)
    identifier      reduce using rule 69 (expression -> expression * expression .)
    END             reduce using rule 69 (expression -> expression * expression .)
    ELSE            reduce using rule 69 (expression -> expression * expression .)
    ,               reduce using rule 69 (expression -> expression * expression .)
    THEN            reduce using rule 69 (expression -> expression * expression .)
    AND             reduce using rule 69 (expression -> expression * expression .)
    OR              reduce using rule 69 (expression -> expression * expression .)
    DO              reduce using rule 69 (expression -> expression * expression .)

  ! +               [ shift and go to state 95 ]
  ! -               [ shift and go to state 98 ]
  ! *               [ shift and go to state 92 ]
  ! /               [ shift and go to state 93 ]


state 124

    (70) expression -> expression / expression .
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression

    ]               reduce using rule 70 (expression -> expression / expression .)
    +               reduce using rule 70 (expression -> expression / expression .)
    -               reduce using rule 70 (expression -> expression / expression .)
    *               reduce using rule 70 (expression -> expression / expression .)
    /               reduce using rule 70 (expression -> expression / expression .)
    =               reduce using rule 70 (expression -> expression / expression .)
    less_equal_sign reduce using rule 70 (expression -> expression / expression .)
    >               reduce using rule 70 (expression -> expression / expression .)
    greater_equal_sign reduce using rule 70 (expression -> expression / expression .)
    <               reduce using rule 70 (expression -> expression / expression .)
    not_equal_sign  reduce using rule 70 (expression -> expression / expression .)
    )               reduce using rule 70 (expression -> expression / expression .)
    BEGIN           reduce using rule 70 (expression -> expression / expression .)
    PRINT           reduce using rule 70 (expression -> expression / expression .)
    READ            reduce using rule 70 (expression -> expression / expression .)
    IF              reduce using rule 70 (expression -> expression / expression .)
    FOR             reduce using rule 70 (expression -> expression / expression .)
    RETURN          reduce using rule 70 (expression -> expression / expression .)
    CALL            reduce using rule 70 (expression -> expression / expression .)
    identifier      reduce using rule 70 (expression -> expression / expression .)
    END             reduce using rule 70 (expression -> expression / expression .)
    ELSE            reduce using rule 70 (expression -> expression / expression .)
    ,               reduce using rule 70 (expression -> expression / expression .)
    THEN            reduce using rule 70 (expression -> expression / expression .)
    AND             reduce using rule 70 (expression -> expression / expression .)
    OR              reduce using rule 70 (expression -> expression / expression .)
    DO              reduce using rule 70 (expression -> expression / expression .)

  ! +               [ shift and go to state 95 ]
  ! -               [ shift and go to state 98 ]
  ! *               [ shift and go to state 92 ]
  ! /               [ shift and go to state 93 ]


state 125

    (67) expression -> expression + expression .
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression

    ]               reduce using rule 67 (expression -> expression + expression .)
    +               reduce using rule 67 (expression -> expression + expression .)
    -               reduce using rule 67 (expression -> expression + expression .)
    =               reduce using rule 67 (expression -> expression + expression .)
    less_equal_sign reduce using rule 67 (expression -> expression + expression .)
    >               reduce using rule 67 (expression -> expression + expression .)
    greater_equal_sign reduce using rule 67 (expression -> expression + expression .)
    <               reduce using rule 67 (expression -> expression + expression .)
    not_equal_sign  reduce using rule 67 (expression -> expression + expression .)
    )               reduce using rule 67 (expression -> expression + expression .)
    BEGIN           reduce using rule 67 (expression -> expression + expression .)
    PRINT           reduce using rule 67 (expression -> expression + expression .)
    READ            reduce using rule 67 (expression -> expression + expression .)
    IF              reduce using rule 67 (expression -> expression + expression .)
    FOR             reduce using rule 67 (expression -> expression + expression .)
    RETURN          reduce using rule 67 (expression -> expression + expression .)
    CALL            reduce using rule 67 (expression -> expression + expression .)
    identifier      reduce using rule 67 (expression -> expression + expression .)
    END             reduce using rule 67 (expression -> expression + expression .)
    ELSE            reduce using rule 67 (expression -> expression + expression .)
    ,               reduce using rule 67 (expression -> expression + expression .)
    THEN            reduce using rule 67 (expression -> expression + expression .)
    AND             reduce using rule 67 (expression -> expression + expression .)
    OR              reduce using rule 67 (expression -> expression + expression .)
    DO              reduce using rule 67 (expression -> expression + expression .)
    *               shift and go to state 92
    /               shift and go to state 93

  ! *               [ reduce using rule 67 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 67 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 95 ]
  ! -               [ shift and go to state 98 ]


state 126

    (56) bool -> expression relop expression .
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression

    THEN            reduce using rule 56 (bool -> expression relop expression .)
    AND             reduce using rule 56 (bool -> expression relop expression .)
    OR              reduce using rule 56 (bool -> expression relop expression .)
    )               reduce using rule 56 (bool -> expression relop expression .)
    +               shift and go to state 95
    -               shift and go to state 98
    *               shift and go to state 92
    /               shift and go to state 93


state 127

    (68) expression -> expression - expression .
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression

    ]               reduce using rule 68 (expression -> expression - expression .)
    +               reduce using rule 68 (expression -> expression - expression .)
    -               reduce using rule 68 (expression -> expression - expression .)
    =               reduce using rule 68 (expression -> expression - expression .)
    less_equal_sign reduce using rule 68 (expression -> expression - expression .)
    >               reduce using rule 68 (expression -> expression - expression .)
    greater_equal_sign reduce using rule 68 (expression -> expression - expression .)
    <               reduce using rule 68 (expression -> expression - expression .)
    not_equal_sign  reduce using rule 68 (expression -> expression - expression .)
    )               reduce using rule 68 (expression -> expression - expression .)
    BEGIN           reduce using rule 68 (expression -> expression - expression .)
    PRINT           reduce using rule 68 (expression -> expression - expression .)
    READ            reduce using rule 68 (expression -> expression - expression .)
    IF              reduce using rule 68 (expression -> expression - expression .)
    FOR             reduce using rule 68 (expression -> expression - expression .)
    RETURN          reduce using rule 68 (expression -> expression - expression .)
    CALL            reduce using rule 68 (expression -> expression - expression .)
    identifier      reduce using rule 68 (expression -> expression - expression .)
    END             reduce using rule 68 (expression -> expression - expression .)
    ELSE            reduce using rule 68 (expression -> expression - expression .)
    ,               reduce using rule 68 (expression -> expression - expression .)
    THEN            reduce using rule 68 (expression -> expression - expression .)
    AND             reduce using rule 68 (expression -> expression - expression .)
    OR              reduce using rule 68 (expression -> expression - expression .)
    DO              reduce using rule 68 (expression -> expression - expression .)
    *               shift and go to state 92
    /               shift and go to state 93

  ! *               [ reduce using rule 68 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 68 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 95 ]
  ! -               [ shift and go to state 98 ]


state 128

    (23) format -> identifier E : . type
    (24) format -> identifier E : . mode type
    (28) type -> . INTEGER
    (25) mode -> . IN
    (26) mode -> . OUT
    (27) mode -> . IN_OUT

    INTEGER         shift and go to state 53
    IN              shift and go to state 140
    OUT             shift and go to state 142
    IN_OUT          shift and go to state 139

    type                           shift and go to state 141
    mode                           shift and go to state 143

state 129

    (22) F_1 -> ; format . F_1
    (21) F_1 -> . empty
    (22) F_1 -> . ; format F_1
    (58) empty -> .

    ;               shift and go to state 102
    )               reduce using rule 58 (empty -> .)

    F_1                            shift and go to state 144
    empty                          shift and go to state 103

state 130

    (18) proc_decl -> PROCEDURE identifier ( F ) ; . block
    (29) block -> . BEGIN A B D END
    (30) block -> . BEGIN A B END

    BEGIN           shift and go to state 35

    block                          shift and go to state 145

state 131

    (33) G -> , expression . G
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression
    (32) G -> . empty
    (33) G -> . , expression G
    (58) empty -> .

    +               shift and go to state 95
    -               shift and go to state 98
    *               shift and go to state 92
    /               shift and go to state 93
    ,               shift and go to state 105
    )               reduce using rule 58 (empty -> .)

    G                              shift and go to state 146
    empty                          shift and go to state 106

state 132

    (31) print -> PRINT ( string_constant G ) .

    BEGIN           reduce using rule 31 (print -> PRINT ( string_constant G ) .)
    PRINT           reduce using rule 31 (print -> PRINT ( string_constant G ) .)
    READ            reduce using rule 31 (print -> PRINT ( string_constant G ) .)
    IF              reduce using rule 31 (print -> PRINT ( string_constant G ) .)
    FOR             reduce using rule 31 (print -> PRINT ( string_constant G ) .)
    RETURN          reduce using rule 31 (print -> PRINT ( string_constant G ) .)
    CALL            reduce using rule 31 (print -> PRINT ( string_constant G ) .)
    identifier      reduce using rule 31 (print -> PRINT ( string_constant G ) .)
    END             reduce using rule 31 (print -> PRINT ( string_constant G ) .)
    ELSE            reduce using rule 31 (print -> PRINT ( string_constant G ) .)


state 133

    (40) call -> CALL identifier ( expression G . )

    )               shift and go to state 147


state 134

    (29) block -> BEGIN A B D END .

    ELSE            reduce using rule 29 (block -> BEGIN A B D END .)
    BEGIN           reduce using rule 29 (block -> BEGIN A B D END .)
    PRINT           reduce using rule 29 (block -> BEGIN A B D END .)
    READ            reduce using rule 29 (block -> BEGIN A B D END .)
    IF              reduce using rule 29 (block -> BEGIN A B D END .)
    FOR             reduce using rule 29 (block -> BEGIN A B D END .)
    RETURN          reduce using rule 29 (block -> BEGIN A B D END .)
    CALL            reduce using rule 29 (block -> BEGIN A B D END .)
    identifier      reduce using rule 29 (block -> BEGIN A B D END .)
    END             reduce using rule 29 (block -> BEGIN A B D END .)
    PROCEDURE       reduce using rule 29 (block -> BEGIN A B D END .)


state 135

    (34) read -> READ ( string_constant H ) .

    ELSE            reduce using rule 34 (read -> READ ( string_constant H ) .)
    BEGIN           reduce using rule 34 (read -> READ ( string_constant H ) .)
    PRINT           reduce using rule 34 (read -> READ ( string_constant H ) .)
    READ            reduce using rule 34 (read -> READ ( string_constant H ) .)
    IF              reduce using rule 34 (read -> READ ( string_constant H ) .)
    FOR             reduce using rule 34 (read -> READ ( string_constant H ) .)
    RETURN          reduce using rule 34 (read -> READ ( string_constant H ) .)
    CALL            reduce using rule 34 (read -> READ ( string_constant H ) .)
    identifier      reduce using rule 34 (read -> READ ( string_constant H ) .)
    END             reduce using rule 34 (read -> READ ( string_constant H ) .)


state 136

    (36) H -> , var . H
    (35) H -> . empty
    (36) H -> . , var H
    (58) empty -> .

    ,               shift and go to state 115
    )               reduce using rule 58 (empty -> .)

    H                              shift and go to state 148
    empty                          shift and go to state 116

state 137

    (59) statement_for -> FOR identifier assign_op TO expression . DO statement
    (67) expression -> expression . + expression
    (68) expression -> expression . - expression
    (69) expression -> expression . * expression
    (70) expression -> expression . / expression

    DO              shift and go to state 149
    +               shift and go to state 95
    -               shift and go to state 98
    *               shift and go to state 92
    /               shift and go to state 93


state 138

    (38) cond -> IF bool THEN statement ELSE . statement
    (44) statement -> . block
    (45) statement -> . print
    (46) statement -> . read
    (47) statement -> . statement_assign
    (48) statement -> . cond
    (49) statement -> . statement_for
    (50) statement -> . return
    (51) statement -> . call
    (29) block -> . BEGIN A B D END
    (30) block -> . BEGIN A B END
    (31) print -> . PRINT ( string_constant G )
    (34) read -> . READ ( string_constant H )
    (43) statement_assign -> . var assign_op expression
    (37) cond -> . IF bool THEN statement
    (38) cond -> . IF bool THEN statement ELSE statement
    (59) statement_for -> . FOR identifier assign_op TO expression DO statement
    (52) return -> . RETURN
    (39) call -> . CALL identifier ( )
    (40) call -> . CALL identifier ( expression G )
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    BEGIN           shift and go to state 35
    PRINT           shift and go to state 33
    READ            shift and go to state 38
    IF              shift and go to state 42
    FOR             shift and go to state 39
    RETURN          shift and go to state 50
    CALL            shift and go to state 34
    identifier      shift and go to state 37

    statement_for                  shift and go to state 32
    return                         shift and go to state 43
    block                          shift and go to state 45
    read                           shift and go to state 36
    cond                           shift and go to state 46
    statement_assign               shift and go to state 47
    statement                      shift and go to state 150
    var                            shift and go to state 40
    call                           shift and go to state 49
    print                          shift and go to state 41

state 139

    (27) mode -> IN_OUT .

    INTEGER         reduce using rule 27 (mode -> IN_OUT .)


state 140

    (25) mode -> IN .

    INTEGER         reduce using rule 25 (mode -> IN .)


state 141

    (23) format -> identifier E : type .

    ;               reduce using rule 23 (format -> identifier E : type .)
    )               reduce using rule 23 (format -> identifier E : type .)


state 142

    (26) mode -> OUT .

    INTEGER         reduce using rule 26 (mode -> OUT .)


state 143

    (24) format -> identifier E : mode . type
    (28) type -> . INTEGER

    INTEGER         shift and go to state 53

    type                           shift and go to state 151

state 144

    (22) F_1 -> ; format F_1 .

    )               reduce using rule 22 (F_1 -> ; format F_1 .)


state 145

    (18) proc_decl -> PROCEDURE identifier ( F ) ; block .

    PROCEDURE       reduce using rule 18 (proc_decl -> PROCEDURE identifier ( F ) ; block .)
    BEGIN           reduce using rule 18 (proc_decl -> PROCEDURE identifier ( F ) ; block .)


state 146

    (33) G -> , expression G .

    )               reduce using rule 33 (G -> , expression G .)


state 147

    (40) call -> CALL identifier ( expression G ) .

    BEGIN           reduce using rule 40 (call -> CALL identifier ( expression G ) .)
    PRINT           reduce using rule 40 (call -> CALL identifier ( expression G ) .)
    READ            reduce using rule 40 (call -> CALL identifier ( expression G ) .)
    IF              reduce using rule 40 (call -> CALL identifier ( expression G ) .)
    FOR             reduce using rule 40 (call -> CALL identifier ( expression G ) .)
    RETURN          reduce using rule 40 (call -> CALL identifier ( expression G ) .)
    CALL            reduce using rule 40 (call -> CALL identifier ( expression G ) .)
    identifier      reduce using rule 40 (call -> CALL identifier ( expression G ) .)
    END             reduce using rule 40 (call -> CALL identifier ( expression G ) .)
    ELSE            reduce using rule 40 (call -> CALL identifier ( expression G ) .)


state 148

    (36) H -> , var H .

    )               reduce using rule 36 (H -> , var H .)


state 149

    (59) statement_for -> FOR identifier assign_op TO expression DO . statement
    (44) statement -> . block
    (45) statement -> . print
    (46) statement -> . read
    (47) statement -> . statement_assign
    (48) statement -> . cond
    (49) statement -> . statement_for
    (50) statement -> . return
    (51) statement -> . call
    (29) block -> . BEGIN A B D END
    (30) block -> . BEGIN A B END
    (31) print -> . PRINT ( string_constant G )
    (34) read -> . READ ( string_constant H )
    (43) statement_assign -> . var assign_op expression
    (37) cond -> . IF bool THEN statement
    (38) cond -> . IF bool THEN statement ELSE statement
    (59) statement_for -> . FOR identifier assign_op TO expression DO statement
    (52) return -> . RETURN
    (39) call -> . CALL identifier ( )
    (40) call -> . CALL identifier ( expression G )
    (41) var -> . identifier
    (42) var -> . identifier [ expression ]

    BEGIN           shift and go to state 35
    PRINT           shift and go to state 33
    READ            shift and go to state 38
    IF              shift and go to state 42
    FOR             shift and go to state 39
    RETURN          shift and go to state 50
    CALL            shift and go to state 34
    identifier      shift and go to state 37

    statement_for                  shift and go to state 32
    return                         shift and go to state 43
    block                          shift and go to state 45
    read                           shift and go to state 36
    cond                           shift and go to state 46
    statement_assign               shift and go to state 47
    statement                      shift and go to state 152
    var                            shift and go to state 40
    call                           shift and go to state 49
    print                          shift and go to state 41

state 150

    (38) cond -> IF bool THEN statement ELSE statement .

    ELSE            reduce using rule 38 (cond -> IF bool THEN statement ELSE statement .)
    BEGIN           reduce using rule 38 (cond -> IF bool THEN statement ELSE statement .)
    PRINT           reduce using rule 38 (cond -> IF bool THEN statement ELSE statement .)
    READ            reduce using rule 38 (cond -> IF bool THEN statement ELSE statement .)
    IF              reduce using rule 38 (cond -> IF bool THEN statement ELSE statement .)
    FOR             reduce using rule 38 (cond -> IF bool THEN statement ELSE statement .)
    RETURN          reduce using rule 38 (cond -> IF bool THEN statement ELSE statement .)
    CALL            reduce using rule 38 (cond -> IF bool THEN statement ELSE statement .)
    identifier      reduce using rule 38 (cond -> IF bool THEN statement ELSE statement .)
    END             reduce using rule 38 (cond -> IF bool THEN statement ELSE statement .)


state 151

    (24) format -> identifier E : mode type .

    ;               reduce using rule 24 (format -> identifier E : mode type .)
    )               reduce using rule 24 (format -> identifier E : mode type .)


state 152

    (59) statement_for -> FOR identifier assign_op TO expression DO statement .

    ELSE            reduce using rule 59 (statement_for -> FOR identifier assign_op TO expression DO statement .)
    BEGIN           reduce using rule 59 (statement_for -> FOR identifier assign_op TO expression DO statement .)
    PRINT           reduce using rule 59 (statement_for -> FOR identifier assign_op TO expression DO statement .)
    READ            reduce using rule 59 (statement_for -> FOR identifier assign_op TO expression DO statement .)
    IF              reduce using rule 59 (statement_for -> FOR identifier assign_op TO expression DO statement .)
    FOR             reduce using rule 59 (statement_for -> FOR identifier assign_op TO expression DO statement .)
    RETURN          reduce using rule 59 (statement_for -> FOR identifier assign_op TO expression DO statement .)
    CALL            reduce using rule 59 (statement_for -> FOR identifier assign_op TO expression DO statement .)
    identifier      reduce using rule 59 (statement_for -> FOR identifier assign_op TO expression DO statement .)
    END             reduce using rule 59 (statement_for -> FOR identifier assign_op TO expression DO statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for identifier in state 5 resolved as shift
WARNING: shift/reduce conflict for identifier in state 15 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 121 resolved as shift
